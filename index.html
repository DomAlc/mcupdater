<!DOCTYPE html>
<html>
<head>
    <title>Arduino STK500 Programmer</title>
</head>
<body>
    <h1>Arduino STK500 Programmer</h1>
    <button onclick="connectSerial()">Conectar a Puerto Serial</button>
    <input type="file" id="hexFile" accept=".hex">
    <button onclick="programArduino()">Programar</button>
    <p id="status"></p>

    <script>
        let port;
        let writer;
        let reader;

        // Conectar al puerto serial
       async function connectSerial() {
            try {
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: 115200 });
        
                // Controlar DTR para reiniciar el Arduino
                await port.setSignals({ dataTerminalReady: true });
                await new Promise(resolve => setTimeout(resolve, 100)); // Esperar 100ms
                await port.setSignals({ dataTerminalReady: false });
        
                writer = port.writable.getWriter();
                reader = port.readable.getReader();
                document.getElementById('status').textContent = 'Conectado!';
            } catch (err) {
                console.error('Error al conectar:', err);
            }
        }

       // Enviar comando STK500 y leer respuesta
        async function sendCommand(cmd) {
            const uint8Array = new Uint8Array(cmd);
            await writer.write(uint8Array);
            const { value } = await reader.read();
            return value;
        }
        
        // Programar el Arduino
        async function programArduino() {
            const file = document.getElementById('hexFile').files[0];
            if (!file || !port) return;
        
            // Parsear HEX
            const hex = await file.text();
            const pages = parseHex(hex);
        
            // Iniciar comunicación
            let response = await sendCommand([0xAC, 0x53, 0x00, 0x00]);
            if (response[2] !== 0x10) {
                alert('No se pudo iniciar el bootloader');
                return;
            }
        
            // Borrar memoria
            await sendCommand([0xAC, 0x80, 0x00, 0x00]);
        
            // Programar cada página
            for (const [address, data] of pages) {
                // Cargar dirección
                const addrHigh = (address >> 8) & 0xFF;
                const addrLow = address & 0xFF;
                await sendCommand([0x55, 0x00, addrHigh, addrLow]);
        
                // Programar página (convierte a Uint8Array)
                const pageCmd = new Uint8Array([0x64, ...data]);
                await sendCommand(pageCmd);
            }
        
            // Salir del modo programación
            await sendCommand([0xAC, 0x51, 0x00, 0x00]);
        
            document.getElementById('status').textContent = '¡Programación exitosa!';
        }

        // Parsear archivo HEX (versión simplificada)
        function parseHex(hex) {
            const pages = [];
            let extendedAddress = 0;
            hex.split('\n').forEach(line => {
                if (line.startsWith(':')) {
                    const bytes = line.slice(1).match(/../g).map(b => parseInt(b, 16));
                    const type = bytes[3];
                    if (type === 0x00) { // Data record
                        const address = (bytes[1] << 8 | bytes[2]) + (extendedAddress << 16);
                        const data = bytes.slice(4, 4 + bytes[0]);
                        pages.push([address, data]);
                    } else if (type === 0x04) { // Extended address
                        extendedAddress = (bytes[4] << 8) | bytes[5];
                    }
                }
            });
            return pages;
        }
    </script>
</body>
</html>
